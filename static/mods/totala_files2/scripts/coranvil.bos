//
// ThunderStorm Turret!
//
// Script and weapon by zwzsg on a model by Bidigam
//

#define WEAPON_RELOADTIME 15000 // Copy back here the value in the weapon TDF
#define WEAPON_RANGE (2200*([0.4])) // Copy back here the value in the weapon TDF, the *[0.4] is to convert the range in pixel into script units
#define WEAPON_COMMANDFIRE 0 // Copy back here the value in the weapon TDF

#define MARK_TARGET FALSE // Show an explosion on the point targetted by the AimPrimary(heading,pitch)

#define AGE_OF_MATURE_CLOUD 2000 // time before the could is ripe for lightening
#define CLOUD_DURATION 13000
#define CLOUD_REFRESH 200
#define CLOUD_POINTS_PER_REFRESH 60
#define CLOUD_ALTITUDE [50]
#define CLOUD_RADIUS [40]
#define LIGHTNING_RADIUS [30]//Somehow all lightnings comes from the first point anyway, so let it be centered. But strangely when centered all lightening hit at same point. So let's center only the first.

#define SCALE 82/100

#define SIGNAL_PRIMAIRE 2
#define SIGNAL_PRIMAIRE_BIS 4
#define SIGNAL_TIR 8
#define SIGNAL_CREATE 16

#define TA
#include "exptype.h"
#include "sfxtype.h"


#if WEAPON_COMMANDFIRE
	#define KILL_AIM_WHEN_TARGET_CLEARED TRUE
	#define REPRESS_AIMING TRUE
#else
	#define KILL_AIM_WHEN_TARGET_CLEARED FALSE
	#define REPRESS_AIMING FALSE
#endif

piece base, block, pillar, turret, turret_glow, barrel, barrel_glow, antennas, antennas_glow, spoilers, handle, invisibilisers, w_door, e_door, aimer, target, cloud_shoulder, cloud_arm, cloud_hand, lightning;

static-var DelayBeforeFoldBack, sav_primary_heading, sav_primary_pitch, chosen_point_xz, busy_blowing, block_angle, firing, sav_firing_xz;



Create()
	{
	DelayBeforeFoldBack=10000;
	busy_blowing=FALSE;
	firing=FALSE;
	dont-shade base;
	dont-shade block;
	dont-shade invisibilisers;
	dont-shade w_door;
	dont-shade e_door;
	dont-shade pillar;
	dont-shade turret;
	dont-shade turret_glow;
	dont-shade barrel;
	dont-shade barrel_glow;
	dont-shade antennas;
	dont-shade antennas_glow;
	dont-shade spoilers;
	dont-shade handle;
	hide invisibilisers;//Let's let digger=1; takes care of that. Ah ok no, it would hide the pit.
	hide w_door;
	hide e_door;
	move aimer to y-axis [2000] now; // 200000 makes very weird things
	//hide turret_glow;
	move turret_glow to z-axis [8.5]*SCALE now;
	hide barrel_glow;
	hide antennas_glow;
	block_angle=(2*rand(0,1)-1)*(<90>);
	turn block to y-axis block_angle now;
	move pillar to z-axis [-5]*SCALE now;
	move handle to z-axis [-5]*SCALE now;
	while(get BUILD_PERCENT_LEFT)
		{
		sleep 100;
		}
	show invisibilisers;
	dont-cache invisibilisers;//remove its shadow
	show w_door;
	show e_door;
	dont-cache w_door;// or else the shadow shows
	dont-cache e_door;// or else the shadow shows
	set-signal-mask SIGNAL_CREATE;// Becomes killeable, so the unfolding in the aiming first kill the following folding
	//move turret to y-axis [-32]*SCALE speed [16]*SCALE;
	move pillar to y-axis [-10]*SCALE speed [16]*SCALE;
	move barrel to z-axis [-27.5]*SCALE speed [27.5]*SCALE;
	move barrel to y-axis [-0.5]*SCALE speed [0.5]*SCALE;
	turn antennas to x-axis <100> speed <50>;
	sleep 625;
	move turret to y-axis [-22]*SCALE speed [16]*SCALE;
	sleep 1375;
	move w_door to x-axis [-10]*SCALE speed [10]*SCALE;
	move e_door to x-axis [10]*SCALE speed [10]*SCALE;
	sleep 1000;
	move w_door to y-axis [5]*SCALE speed [10]*SCALE;
	move e_door to y-axis [5]*SCALE speed [10]*SCALE;
	sleep 500;
	set ARMORED to TRUE;
	
	}


SetMaxReloadTime(time)
	{
	DelayBeforeFoldBack=time*3/2;
	}


#if REPRESS_AIMING
SmokeALotThenFoldIn()
	{
	var t,p;
	turn cloud_shoulder to y-axis get XZ_ATAN(get PIECE_XZ(base) - chosen_point_xz) now;
	move cloud_arm to z-axis get XZ_HYPOT(get PIECE_XZ(base) - chosen_point_xz) now;
	move cloud_hand to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(chosen_point_xz) - get PIECE_Y(base) now;
	move lightning to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(chosen_point_xz) - get PIECE_Y(base) now;
	move lightning to z-axis 0 now;//Somehow all lightnings comes from the first point anyway, so let it be centered. But strangely when centered all lightening hit at same point. So let's center only the first.
	for(t=0;t<=CLOUD_DURATION;t=t + CLOUD_REFRESH)
		{
		for(p=CLOUD_POINTS_PER_REFRESH;p>=1;--p)
			{
			turn cloud_arm to y-axis rand(0,65536) now;
			move cloud_hand to z-axis rand(0,CLOUD_RADIUS) now;
			if(has_fired)
				{
				move lightning to z-axis rand(0,LIGHTNING_RADIUS) now;
				}
			emit-sfx SFXTYPE_WHITESMOKE from cloud_hand;
			}
		sleep CLOUD_REFRESH;
		if (t>AGE_OF_MATURE_CLOUD)
			{
			if(!firing)
				{
				t=5+CLOUD_DURATION;
				}
			}
		}
#else
OnlyFoldIn()
	{
	sleep WEAPON_RELOADTIME + 1500;
#endif
	cache turret_glow;
	cache barrel_glow;
	cache antennas_glow;
	//hide turret_glow;
	move turret_glow to z-axis [8.5]*SCALE speed [6]*SCALE;
	hide barrel_glow;
	hide antennas_glow;
	sleep WEAPON_RELOADTIME - CLOUD_DURATION + AGE_OF_MATURE_CLOUD + 1500;
	busy_blowing=FALSE;// Make sure that is after the weapon has reloaded
	sleep 300;
	turn turret to y-axis <0> speed <30>;
	wait-for-turn turret around y-axis;
	//move turret to y-axis [-32]*SCALE speed [16]*SCALE;
	move pillar to y-axis [-10]*SCALE speed [16]*SCALE;
	move barrel to z-axis [-27.5]*SCALE speed [27.5]*SCALE;
	move barrel to y-axis [-0.5]*SCALE speed [0.5]*SCALE;
	turn antennas to x-axis <100> speed <50>;
	sleep 625;
	move turret to y-axis [-22]*SCALE speed [16]*SCALE;
	sleep 1375;
	move turret to y-axis [-22]*SCALE speed [5]*SCALE;
	move w_door to x-axis [-10]*SCALE speed [10]*SCALE;
	move e_door to x-axis [10]*SCALE speed [10]*SCALE;
	sleep 1000;
	move w_door to y-axis [5]*SCALE speed [10]*SCALE;
	move e_door to y-axis [5]*SCALE speed [10]*SCALE;
	sleep 500;
	set ARMORED to TRUE;
	}

AimFromPrimary(piece_to_aim_from)
	{
	piece_to_aim_from=aimer;
	}

AimPrimary(heading,pitch)
	{
	
	#if REPRESS_AIMING
	if(busy_blowing)
		{
		signal SIGNAL_PRIMAIRE_BIS;
		set-signal-mask SIGNAL_PRIMAIRE_BIS;
		while(busy_blowing)
			{
			sleep 200;
			}
		}
	#endif
	
	signal SIGNAL_PRIMAIRE;
	set-signal-mask SIGNAL_PRIMAIRE;
	
	sav_primary_heading=heading;
	sav_primary_pitch=pitch;
	
	
	// Script to determine the absolute xz position of target point
	// Works only for LOS weapon, and within range
	// The idea is:
	// - Put the turret center on a very up position
	// - Wait till an aiming is done
	// - Retrieve the heading and pitch
	// - Turn the turret accordingly
	// - Move a piece further and further folling the weapon LOS, until it goes underground
	// - Use dichotomia inside the interval [turret, point underground] to find the exact limit where the piece moving along weapon LOS goes through ground
	// - Use that position as xz
	
	
	var arm_length, arm_length_inc, zhypsqthsq, wfpc_rxz, wfpc_ro, wfpc_theta;
	
	
	if (sav_primary_pitch<= 32768)// to prevent any lock
		{
		explode turret type SHATTER | BITMAPNUKE;
		show turret;
		//start-script ExtinguishWormHole();
		while(TRUE)
			{
			sleep 12600000;
			}
		return;
		}

	turn aimer to y-axis sav_primary_heading now;
	turn aimer to x-axis (0 - sav_primary_pitch) now;
   	move target to z-axis 0 now;
   	arm_length=1;
   	while (get GROUND_HEIGHT(get PIECE_XZ(target))<get PIECE_Y(target) && arm_length!=2147483646)//while target_point is over the ground
   		{
   		arm_length=arm_length*2;
   		
   		if (arm_length==1073741824)//another, better, lock prevention
   			{arm_length=1073741823;}//another, better, lock prevention
   		
   		move target to z-axis arm_length now;
   		//wait-for-move target along z-axis;
   		//explode target type BITMAPONLY | BITMAP2;
   		}
   	
	arm_length_inc=arm_length/2;
	arm_length=0;
   	while (arm_length_inc>0)
   		{
   		move target to z-axis (arm_length + arm_length_inc) now;
   		//wait-for-move target along z-axis;
   		//explode target type BITMAPONLY | BITMAPNUKE;
   		if (get GROUND_HEIGHT(get PIECE_XZ(target))<=get PIECE_Y(target))//if target_point is over the ground
   			{
   			arm_length=arm_length +	 arm_length_inc;
   			}
   		arm_length_inc=arm_length_inc/2;
   		}
   	

	if (arm_length==2147483616)// Yes, 16 not 46.// Detect when it was not able to find the intersection between the ground and the line of fire
   		{
		explode turret type SHATTER | BITMAPNUKE;
		explode block type SHATTER | BITMAP3;
		show turret;
		show block;
		//start-script ExtinguishWormHole();
		while(TRUE)
			{
			sleep 12600000;
			}
		return;
   		}
   	
   	
   	zhypsqthsq=get PIECE_Y(aimer) + get PIECE_Y(target);
   	zhypsqthsq=arm_length*arm_length - zhypsqthsq*zhypsqthsq;
   	zhypsqthsq=get HYPOT(zhypsqthsq,zhypsqthsq);// get HYPOT(var,var) is square root of var

	chosen_point_xz=get PIECE_XZ(target);
	
	#if MARK_TARGET
	explode target type BITMAPONLY | BITMAP2;
	#endif
	
	turn aimer to y-axis <0> now;
   	turn aimer to x-axis <0> now;
   	move target to z-axis 0 now;
	
	wfpc_rxz=get PIECE_XZ(base) - chosen_point_xz;
	
	//vortex_xz_entry=chosen_point_xz;
	
	if((get XZ_HYPOT(get PIECE_XZ(base) - chosen_point_xz))>WEAPON_RANGE)
		{
		while(1)
			{
			sleep 16777215;
			}
		}
	
	signal SIGNAL_CREATE;// Kill the Create() script, so as to kill the folding back at the end of the Create()
	move w_door to y-axis [0]*SCALE speed [10]*SCALE;
	move e_door to y-axis [0]*SCALE speed [10]*SCALE;
	wait-for-move w_door along y-axis;
	set ARMORED to FALSE;
	move w_door to x-axis [0]*SCALE speed [10]*SCALE;
	move e_door to x-axis [0]*SCALE speed [10]*SCALE;
	wait-for-move w_door along x-axis;
	move turret to y-axis [0]*SCALE speed [16]*SCALE;
	turn antennas to x-axis <0> speed <50>;
	sleep 1000;
	move barrel to y-axis [0]*SCALE speed [0.5]*SCALE;
	move barrel to z-axis [0]*SCALE speed [27.5]*SCALE;
	wait-for-move turret along y-axis;
	move pillar to y-axis [0]*SCALE speed [16]*SCALE;
	wait-for-move turret along y-axis;
	wait-for-move barrel along y-axis;
	wait-for-move barrel along z-axis;
	turn turret to y-axis get XZ_ATAN(get PIECE_XZ(base) - chosen_point_xz) - block_angle speed <30>;
	wait-for-turn turret around y-axis;
	busy_blowing=TRUE;
	show turret_glow;
	move turret_glow to z-axis [0]*SCALE speed [12]*SCALE;
	show barrel_glow;
	show antennas_glow;
	dont-cache turret_glow;
	dont-cache barrel_glow;
	dont-cache antennas_glow;
	firing=FALSE;
	#if REPRESS_AIMING
	start-script SmokeALotThenFoldIn();
	sleep AGE_OF_MATURE_CLOUD;
	#else
	/*var t,p;
	//if(done_firing)
		//{
		for(t=0;t<=AGE_OF_MATURE_CLOUD;t=t + CLOUD_REFRESH)
			{
			turn cloud_shoulder to y-axis get XZ_ATAN(get PIECE_XZ(base) - chosen_point_xz) now;
			move cloud_arm to z-axis get XZ_HYPOT(get PIECE_XZ(base) - chosen_point_xz) now;
			move cloud_hand to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(chosen_point_xz) - get PIECE_Y(base) now;
			move lightning to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(chosen_point_xz) - get PIECE_Y(base) now;
			for(p=CLOUD_POINTS_PER_REFRESH;p>=1;--p)
				{
				turn cloud_arm to y-axis rand(0,65536) now;
				move cloud_hand to z-axis rand(0,CLOUD_RADIUS) now;
				emit-sfx SFXTYPE_WHITESMOKE from cloud_hand;
				}
			turn cloud_shoulder to y-axis get XZ_ATAN(get PIECE_XZ(base) - sav_firing_xz) now;
			move cloud_arm to z-axis get XZ_HYPOT(get PIECE_XZ(base) - sav_firing_xz) now;
			move cloud_hand to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(sav_firing_xz) - get PIECE_Y(base) now;
			move lightning to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(sav_firing_xz) - get PIECE_Y(base) now;
			sleep CLOUD_REFRESH;
			}
		//}*/
	while(firing)
		{
		sleep 100;
		}
	start-script OnlyFoldIn();
	sav_firing_xz=chosen_point_xz;
	#endif
	return(TRUE);
	}

QueryPrimary(piece_to_fire_from)
	{
	piece_to_fire_from=lightning;
	#if REPRESS_AIMING
	return;
	#else
	turn cloud_shoulder to y-axis get XZ_ATAN(get PIECE_XZ(base) - sav_firing_xz) now;
	move cloud_arm to z-axis get XZ_HYPOT(get PIECE_XZ(base) - sav_firing_xz) now;
	move cloud_hand to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(sav_firing_xz) - get PIECE_Y(base) now;
	move lightning to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(sav_firing_xz) - get PIECE_Y(base) now;
	move lightning to z-axis 0 now;//Somehow all lightnings comes from the first point anyway, so let it be centered. But strangely when centered all lightening hit at same point. So let's center only the first.
	#endif
	}

FirePrimary()
	{
	#if REPRESS_AIMING
	return;
	#else
	signal SIGNAL_TIR;// Normally never needed, as by the time the next shot is fired, the previous FirePrimary is done, but just in case, kill any previous FirPrimary that would still be running. Even if there should be none.
	set-signal-mask SIGNAL_TIR;
	firing=TRUE;
	var t,p,xz;
	xz=sav_firing_xz;
	for(t=0;t<=CLOUD_DURATION - AGE_OF_MATURE_CLOUD;t=t + CLOUD_REFRESH)
		{
		turn cloud_shoulder to y-axis get XZ_ATAN(get PIECE_XZ(base) - xz) now;
		move cloud_arm to z-axis get XZ_HYPOT(get PIECE_XZ(base) - xz) now;
		move cloud_hand to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(xz) - get PIECE_Y(base) now;
		move lightning to y-axis CLOUD_ALTITUDE + get GROUND_HEIGHT(xz) - get PIECE_Y(base) now;
		for(p=CLOUD_POINTS_PER_REFRESH;p>=1;--p)
			{
			turn cloud_arm to y-axis rand(0,65536) now;
			move cloud_hand to z-axis rand(0,CLOUD_RADIUS) now;
			move lightning to z-axis rand(0,LIGHTNING_RADIUS) now;
			emit-sfx SFXTYPE_WHITESMOKE from cloud_hand;
			}
		sleep CLOUD_REFRESH;
		}
	firing=FALSE;
	#endif
	}

#if KILL_AIM_WHEN_TARGET_CLEARED
TargetCleared(which)
	{
	signal SIGNAL_PRIMAIRE_BIS;
	return;
	}
#endif

SweetSpot(piece_enemies_will_aim_at)
	{
	piece_enemies_will_aim_at=turret;
	}

Killed(severity,corpsetype)
	{
	corpsetype=1;
	if(severity>=33)
		{corpsetype=2;}
	if(severity>=67)
		{corpsetype=3;}
	if(severity>=100)
		{corpsetype=4;}
	explode pillar type FALL | SMOKE | FIRE | EXPLODE_ON_HIT | BITMAP1;
	explode antennas type SHATTER | EXPLODE_ON_HIT | BITMAP1;
	explode turret type FALL | SMOKE | FIRE | EXPLODE_ON_HIT | BITMAP2;
	explode turret_glow type BITMAPONLY | BITMAP4;
	explode w_door type FALL | SMOKE | FIRE | EXPLODE_ON_HIT | BITMAP4;
	explode e_door type FALL | SMOKE | FIRE | EXPLODE_ON_HIT | BITMAP4;
	if(corpsetype==1)
		{explode turret type SHATTER | EXPLODE_ON_HIT | BITMAP2;}
	if(corpsetype>=2)
		{explode barrel type FALL | SMOKE | FIRE | EXPLODE_ON_HIT | BITMAP3;}
	if(corpsetype>=3)
		{explode turret type FALL | SMOKE | FIRE | EXPLODE_ON_HIT | BITMAP2;}
	return;
	}
